\documentclass[10pt]{beamer}
\usetheme{Goettingen}

\usepackage[french]{babel}
\usepackage[T1]{fontenc}

\usepackage{amsmath}
\usepackage{algpseudocode}

\usepackage{algorithm}
%\usepackage{algorithmic}
\newcommand{\kw}[1]{\textrm{#1}}

\usepackage{forest}

%\usepackage{scrextend}
%\changefontsizes{7.5pt}

\usefonttheme[onlymath]{serif}

\usepackage{xcolor}
\usepackage{graphicx} 
\usepackage{amsmath} 
\setlength{\unitlength}{1mm}
%\usepackage{enumitem}
\usepackage{cancel}
\usepackage{amssymb} % pour les ensembles NN
\usepackage{mathrsfs} % pour les hypothèses de récurrences \PP
%\usepackage{fancyhdr}
\usepackage{multicol}


\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{array,collcell}
\newcommand\AddLabel[1]{%
  \refstepcounter{equation}% increment equation counter
  (\theequation)% print equation number
  \label{#1}% give the equation a \label
}
\newcolumntype{M}{>{\hfil}X<{\hfil}} % mathematics column
%\newcolumntype{M}{>{\hfil$\displaystyle}X<{$\hfil}} % mathematics column
%\newcolumntype{L}{>{\collectcell\AddLabel}r<{\endcollectcell}}
\renewcommand\tabularxcolumn[1]{m{#1}}% for vertical centering text in X column

\usepackage{tikz}
\usetikzlibrary{calc, shapes}

\usepackage{tkz-graph}
\tikzset{EdgeStyle/.append style = {->}}
\tikzset{LabelStyle/.style= {draw,
fill = white,
text = black}}

\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=1pt] (char) {#1};}}

% ensembles N,Z,Q,D,R,C
\DeclareMathOperator{\NN}{\mathbb{N}}
\DeclareMathOperator{\ZZ}{\mathbb{Z}}
\DeclareMathOperator{\QQ}{\mathbb{Q}}
\DeclareMathOperator{\DD}{\mathbb{D}}
\DeclareMathOperator{\RR}{\mathbb{R}}
\DeclareMathOperator{\CC}{\mathbb{C}}
\DeclareMathOperator*{\argmax}{\arg\!\max}

\title{TIPE 2024}
\subtitle{Apprendre à une intelligence artificielle à jouer à Snake en utilisant un algorithme génétique}
\author{Marilou Bernard de Courville}
\institute{N\textsuperscript{\underline{o}} SCEI 41188}
\date{\today}

\setbeamertemplate{footline}[frame number]


\begin{document}
 
\begin{frame}
    \titlepage
\end{frame}

%\begin{frame}
%    \frametitle{Table des matières}
%    \tableofcontents
%\end{frame}

\section{Introduction}

\begin{frame}
\frametitle{Introduction}
\framesubtitle{Problématique et pertinence au regard du thème de l'année}

\begin{itemize}
\item \textbf{Objectif:} parcourir efficacement la ville dans un but touristique.
\item \textbf{Recherche opérationnelle:} permet d'atteindre l'objectif en réalisant des optimisations sous contraintes $[1]$.
\item \textbf{Deux cas} envisagés:
  \begin{enumerate}
  \item optimiser un trajet en métro via l'algorithme de Dijkstra et différentes structures de données codées en OCaml $[3]$;
  \item optimiser un trajet soit en métro ou à pied en passant par plusieurs types de chemins en utilisant un solveur linéaire (CPLEX d'IBM) et un code en Python.
  \end{enumerate}
\item Ces deux cas sont modélisés à l'aide de \textbf{graphes orientés}.
\end{itemize}

\end{frame}

\section{\textbf{1\ier{} objectif}: un trajet efficace en métro}

\subsection{Données du problème}

\subsection{Algorithme de Dijkstra, structures de données}

\begin{frame}
\frametitle{Trajet le plus court en métro - modélisation}
\framesubtitle{Modèles de données utilisés (types)}

\small
\begin{itemize}
\item Un tas est une représentation organisée en arbre des stations en fonction d'une priorité (distance du chemin).
\item Représentation en tas (heap) efficace en complexité pour accéder au n\oe ud de priorité minimum et mettre à jour les priorités.
\item Trois structures étudiées: tas non modifiables (\textit{immutable heaps}), tas modifiables, et tarbres (\textit{treap}).
\item Programmes réalisés en OCaml utilisent seulement le module \texttt{Hashtbl} de la bibliothèque standard pour manipuler les tas.
\end{itemize}

\begin{columns}[T]
\begin{column}{0.5\textwidth}
\tiny
\forestset{default preamble={for tree={circle,draw}}}
\begin{forest}
[2[4[5[14][9]][6[11][10]]][7[8[12]][13]]]
\end{forest}

\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}
    \hline
    2 & 4 & 7 & 5 & 6 & 8 & 13 & 14 & 9 & 11 & 10 & 12\\
    \hline
\end{tabular}
\\
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\textbf{Élément} & 2 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 \\
\hline
\textbf{Position} & 0 & 1 & 3 & 4 & 2 & 5 & 8 & 10 & 9 & 11 & 6 & 7 \\
\hline
\end{tabular}
\end{column}
\begin{column}{0.5\textwidth}
\tiny
\forestset{default preamble={for tree={circle,draw}}}
rg0: 
\begin{forest}
[]
\end{forest}
rg1: 
\begin{forest}
[[]]
\end{forest}
rg2: 
\begin{forest}
[[[]][]]
\end{forest}
rg3: 
\begin{forest}
[[[[]][]][[]][]]
\end{forest}
\end{column}
\end{columns}
\end{frame}


\begin{frame}
\frametitle{Trajet le plus court en métro - algorithme}
\framesubtitle{Algorithme de Dijkstra et influence des structures de données sur la complexité}

\begin{columns}[T]
\begin{column}{0.5\textwidth}
\scriptsize
\begin{algorithmic}[0]
\Require Un graphe $G=(V,A)$, $V$ sommets, $A$ arêtes 
\Require Un noeud source $s$
\Ensure $d$ tableau des plus court chemins de $s$ vers $v\in V$
\ForAll {$v \in V[G]$}
    \State $d[v] \leftarrow +\infty$, $\kw{père}[v] \leftarrow \kw{None}$
\EndFor
\State $d[s] \leftarrow 0$, $S \leftarrow \kw{$\emptyset$}$, $Q \leftarrow V[G]$
\While{$Q \neq \emptyset$} 
    \State $u \leftarrow  \kw{Extrait}_{\kw{Min}}(Q)$
    \State $S \leftarrow  S \cup \{u\}$
    \ForAll{arête $(u,v)$ d'origine $u$}  
    \If{$d[u] + w(u,v) < d[v]$}
        \State $d[v] \leftarrow d[u] + w(u,v)$, $\kw{père}[v] := u$ 
    \EndIf
    \EndFor
\EndWhile
\end{algorithmic}
\end{column}
\begin{column}{0.5\textwidth}
\scriptsize

\begin{table}[h]\vspace{-0.5cm}
\centering
\caption{Dijkstra: complexité (opérations)}
%\label{tab:dijkstra-complexity}
\hspace{-0.5cm}
\begin{tabular}{|l|l|}
\hline
\textbf{Implantation}	& \textbf{Complexity} \\ \hline
Naif					& $\mathcal{O}\left(V^2 + A\right)$             \\ \hline
Tas						& $\mathcal{O}\left((V + A) \log V\right)$      \\ \hline
\end{tabular}
\end{table}

\begin{table}[h]\vspace{-0.5cm}
\centering
\caption{Simulations: temps exécution pour toutes les stations du métro}
\hspace{-0.5cm}
\begin{tabular}{|c|c|}
\hline
\textbf{Type} & \textbf{Temps exécution} \\
\hline
\textbf{Naif} &960ms \\
\hline
\textbf{Tas non mutable v1} &312ms \\
\hline
\textbf{Tas mutable} &191ms \\
\hline
\textbf{Tarbre} &1018ms \\
\hline
\textbf{Tas non mutable v2} &145ms \\
\hline
\end{tabular}
\end{table}

\end{column}
\end{columns}

\end{frame}

\subsection{Résultat: stations les plus éloignées}

\section{\textbf{2\ieme{} objectif}: un trajet constitué de plusieurs types de chemins}

\subsection{Cas préliminaire du métro}

\begin{frame}
\frametitle{Plus compliqué: plus petit chemin passant par toutes les lignes du métro}
\framesubtitle{Étude de la résolution à l'aide d'un solveur linéaire}
% https://interstices.info/quel-trajet-optimal-pour-passer-au-moins-une-fois-par-toutes-les-lignes-de-metro/
\begin{itemize}
\item Sujet traité par Florian Sikora $[7]$ par étude de graphe coloré pour le réseau du métro;
\item Sommet: station, arête: trajet entre deux stations connexes, arête colorée par la couleur de la ligne reliant les stations
\item Problème du "Generalised directed rural postman" $[2]$;
\item Problème NP-difficile: pas de solution en temps polynomial $[6]$;
\item Résolution requiert l'utilisation d’un solveur linéaire (CPLEX d'IBM) pour "integer linear programming" (ILP) $[9]$;
\item Fait intervenir une matrice de contraintes (MIP) de \texttt{1270x1847, 6999 coeffs non nuls}.
\end{itemize}
\end{frame}

\subsection{Formalisation du problème}

\begin{frame}
\frametitle{Formalisation du problème: variables}
%\framesubtitle{Objectif - caractérisation des variables}

\begin{itemize}
\item Ensemble $V$ des sommets, $A$ des arêtes, $C$ des couleurs.
$(u,v)\in V^2$, $u \xrightarrow[l\in C]{} v\in A$.

\item $x_{u,v,l}\in \lbrace 0,1 \rbrace$: variable binaire pour chaque arc $u \xrightarrow[l]{} v$ (sur ligne $l$), avec $x=1$ si l'arc est considéré, $x=0$ sinon.

\item $w_{u,v,l}\in \NN$: est le temps pour parcourir l'arête $u \xrightarrow[l]{} v$

\item $(u,v)\in V^2, f_{u,v,l}, y_v \in\NN$ sont les flots des arcs/sommets: positifs si l'arc/sommet est sur le chemin considéré.

\item $s, t$ sont les points de départ/arrivée fictifs (temps nul pour rejoindre tout sommet).
\item  $\forall ((u,v,l_1), (v,w,l_2)) \in A^2, z_{u,v,w,l_1,l_2} \in \lbrace 0,1 \rbrace$ indique si deux arêtes sont utilisées consécutivement $u \xrightarrow[l_1]{} v\xrightarrow[l_2]{} w$.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Formalisation du problème: optimisation}
\small
Objectif: minimiser distance $\displaystyle \sum_{(u,v,l)\in A} w_{u,v,l}\times x_{u,v,l}$ sous contraintes.
%\fontsize{7}{8}\selectfont
\scriptsize
\vspace{-0.2cm}\begin{table}[]
\begin{tabularx}\textwidth{@{}>{\hsize=0.3\textwidth\linewidth=\textwidth}X|>{\hsize=0.6\textwidth\linewidth=\textwidth}M>{\hsize=0.1\textwidth\linewidth=\textwidth}r@{}}
\hline
Autant de chemins qui entrent sur un sommet et qui en sortent: & 
$\displaystyle \forall v \in V\backslash \lbrace s,t \rbrace, \newline \sum_{(u,v,l) \in A} x_{u, v, l} = \sum_{(v,w,l) \in A} x_{v, w, l}$ & (1) \\ \hline
Unique chemin de la source et vers la cible: &
$\displaystyle \sum_{(s,v,l) \in A} x_{s, v, l} = \sum_{(u,t,l) \in A} x_{u, t, l} = 1$ & (2)\\ \hline
Pour chaque ligne au moins 1 arc de cette ligne sélectionné: &
$\displaystyle \forall l \in C, \sum_{(u,v,l) \in A} x_{u, v, l} \geq 1$ & (3)\\ \hline
Evite solutions disjointes: le flot est décroissant pour solution connectée &
$\displaystyle \forall (u,v,l) \in A, \mid V \mid  x_{u,v,l} \geq f_{u,v,l}$ & (4) \\ \hline
Tous les sommets perdent du flot sauf la source: &
$\displaystyle \forall v \in V\backslash \lbrace s \rbrace, \newline \sum_{(u,v,l) \in A} f_{u, v, l} - \sum_{(v,w,l) \in A} f_{v, w, l} \geq y_v$ & (5) \\ \hline
Le flot au niveau du sommet est positif s'il est dans la solution: &
$\displaystyle \forall v \in V, \newline y_v - \sum_{(u,v,l) \in A} x_{u, v, l} - \sum_{(v,w,l) \in A} f_{v, w, l} \geq 0$ & (6) \\ \hline
Evite de prendre deux fois le même sommet: &
$\displaystyle y_v \geq 2$ & (7) \\ \hline
Chemin consécutif: &
$\displaystyle x_{u,v,l_1} + x _{v,w,l_2} \leq z_{u,v,w,l_1,l_2} + 1$ & (8) \\ \hline
Evite de reprendre deux fois la même ligne: &
$\displaystyle \forall l \in C, \newline \sum_{(u,v,l_1),(v,w,l_2) \text{ / } l=l_1 \text{ ou } l=l_2} z_{u,v,w,l_1,l_2} = 2$ & (9) \\ \hline
\end{tabularx}
\end{table}

%\begin{columns}
%\begin{column}{0.5\textwidth}
%\end{column}
%\begin{column}{0.5\textwidth}
%\end{column}
%\end{columns}

%\begin{center}
%\includegraphics[width=0.5\textwidth]{image1.jpg}
%\end{center}

\end{frame} 

\subsection{Résolution, application au cadre de la ville}



\section{Conclusion}

\begin{frame}
\frametitle{Conclusion}
\begin{itemize}
\item Deux problématiques urbaines traitées: 
  \begin{itemize}
  \item optimisation d'un trajet en métro
  \item parcours touristique efficace d'une ville en empruntant différents types de chemins
  \end{itemize}
\item Pertinence de la modélisation des problèmes urbains par des graphes pour les résoudre.
\item Application de la recherche opérationnelle pour trouver une solution.
  \begin{itemize}
  \item Optimisation fait intervenir un grand nombre de contraintes
résultant en des problèmes combinatoires complexes sans solution analytique.
  \item Importance du choix des algorithmes et structures de données pour obtenir des solutions pratiques efficaces.
  \end{itemize}
\end{itemize}
\end{frame}


\end{document}